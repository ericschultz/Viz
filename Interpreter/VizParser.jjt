	options
	{
		LOOKAHEAD = 2;
		FORCE_LA_CHECK = true;
		MULTI = true;
		VISITOR = true;
		NODE_PACKAGE = "Interpreter";
	}

	PARSER_BEGIN(VizParser)
	package Interpreter;
	
	import java.util.*;
	
	public class VizParser
	{
		public static void main(String[] args)
		{
			try
			{
				VizParser vp = new VizParser(System.in);
				ASTProgram program = (ASTProgram)vp.program();
				System.out.println("Before Visitor");
				System.out.println("Dumping: \n");
				program.dump(">");
				System.out.println("After Visitor");

				ASTDeclarationList dl = (ASTDeclarationList) program.jjtGetChild(0);
				for (int i = 0; i < dl.jjtGetNumChildren(); i++)
				{
					System.out.println(dl.jjtGetChild(i));
				}
				System.out.println("SuccessfullyParsed");
				HashMap<String, ASTFunction> funs = Global.getFunctions();
				SymbolTable table = Global.getCurrentSymbolTable();

				System.out.println("Dumping: \n");
				program.dump(">");
				System.out.println("________________\n");
				System.out.println(program.getCode());
				
				System.out.println("\n\n Testing Interpret Visitor");
				
				InterpretVisitor iv = new InterpretVisitor();
				
				program.jjtAccept(iv, null);
				
				System.out.println(Global.getString());
			}
			catch (Exception e)
			{
				System.out.println(e);
			}
		}
	}

	PARSER_END(VizParser)

	TOKEN:
	{
		<DEF: "def" >
		| <VAR: "var" >
		| <NUM: ["0"-"9"] (["0"-"9"])* >
		| <ID: <LETTER> (<LETTER>)* >
		| <LETTER: ["a"-"z", "A"-"Z"] >
		| <LTBCE: "{" >
		| <RTBCE: "}" >
		| <LTBCR: "[" >
		| <RTBCR: "]" >
		| <LTPRN: "(" >
		| <RTPRN: ")" >	
		| <SEMI: ";" >
		| <COMMA: "," >
		| <PLUS: "+" >
		| <MINUS: "-" >
		| <EQL: "=" >
		| <FILL: "<FILL>" >
	}

	SKIP:
	{
		" "
		| "\t"
		| "\n"
		| "\r"
	}


	SimpleNode program() #Program:
	{
		SimpleNode dl;
	}
	{
		
		dl = declarationList()
		{
			//System.out.println("There are " + dl.jjtGetNumChildren() + " global declarations");
			dl.jjtSetParent(jjtThis);	
			return (SimpleNode) jjtThis;
		}
	}

	SimpleNode declarationList() #DeclarationList:
	{
		SimpleNode dl = null;
	}
	{
		declaration() ( declarationListP())?
		{
			return (SimpleNode)jjtThis;
		}
	}
	
	void declarationListP() #void:
	{
	
	}
	{
		declaration() (declarationListP())?
		{
		
		}
	}
	
	

	SimpleNode declaration() #Declaration:
	{
		SimpleNode fun;
		SimpleNode varDecl;
	}
	{
		<VAR> varDecl = varDecl() <SEMI>
		{
			varDecl.jjtSetParent(jjtThis);	
			return jjtThis;
		}
		| fun =  funDecl()
		{
			fun.jjtSetParent(jjtThis);
			return (SimpleNode)jjtThis;
		}
	}

	SimpleNode varDecl() #VarDecl:
	{
		Token t;
		boolean isArray = false;
	}
	{
		t = <ID> (isArray = arrayBrackets())? <EQL> varDeclP()
		{
			jjtThis.setName(t.image);
			Global.getCurrentSymbolTable().put(t.image, new ByValVariable(-255));
			jjtThis.setIsArray(isArray);
			return (SimpleNode) jjtThis;
		} 
	}
	
	boolean arrayBrackets() #void:
	{
	}
	{
		<LTBCR> <RTBCR>
		{
			return true;
		}
	}
	
	void varDeclP() #void:
	{
	}
	{
		<LTBCE> arrayDecl() <RTBCE> | expression()
	}
	

	void arrayDecl() #ArrayDeclaration:
	{
	}
	{
		num() (<COMMA> arrayDeclP())?
	}
	
	void arrayDeclP() #void:
	{
	}
	{
		num() (<COMMA> arrayDeclP())?
	}

	SimpleNode funDecl() #Function:
	{
		Token name;
		ArrayList<String> parameters = new ArrayList<String>();
	}
	{
		<DEF> name = <ID> <LTPRN> (parameters =  params())? <RTPRN> compoundStatement()
		{
			Global.setCurrentSymbolTable(jjtThis.getSymbolTable());
			jjtThis.setName(name.image);
			for (String p : parameters)
			{
				//FIXME: multiple variable types
				Global.getCurrentSymbolTable().put(p, new ByValVariable(255));
				jjtThis.addParameter(p);
			}
			if(Global.addFunction(jjtThis))
			{
				//System.out.println("Successfully added a function");
			}
			return (SimpleNode) jjtThis;
		}
	}

	void compoundStatement() #void:
	{
	}
	{
		<LTBCE> statementList() <RTBCE>
	}

	void statementList() #StatementList:
	{
	}
	{
		statement() (statementListP())? | <FILL>
	}
	
	void statementListP() #void:
	{
	}
	{
		statement() (statementListP())?
	}

	void statement() #Statement:
	{
	}
	{
		 expression() <SEMI> |  <VAR> varDecl() <SEMI>
	}

	void call() #Call:
	{
		Token t;
	}
	{
		t = <ID> <LTPRN> (args())? <RTPRN>
		{
			jjtThis.setName(t.image);
		}
	}

	String var() #Var:
	{
		Token t;
		boolean isArray = false;
		
	}
	{
		t = <ID> (<LTBCR> isArray = expression() <RTBCR> )?
		{
			jjtThis.setName(t.image);
			jjtThis.setIsArray(isArray);
			return t.image;
		}
	}

	void assignment() #Assignment:
	{
		String name = "";
	}
	{
		name = var() <EQL> expression()
	}

	boolean expression() #Expression:
	{
		ASTVar variable;
	}
	{
		 call() {return true;} |
		 assignment() {return true;} |
		 op() {return true;} | 
		 num() {return true;} | 
		 var(){ return true;}
		 
	}	
	

	void args() #Args:
	{
	}
	{
		var() (<COMMA> argsP())?
	}
	
	void argsP() #void:
	{
	}
	{
		var() (<COMMA> argsP())?
	}

	ArrayList<String> params() #void:
	{
		ArrayList<String> names = new ArrayList<String>();
		Token newName;
	}
	{
		newName = <ID> (<COMMA> names = params())?
		{
			names.add(newName.image);
			//System.out.println("Returning names: " + names.size());
			return names;
		}
	}
	
	void op() #Op:
	{
		Token t;
	}
	{
		(var() | num()) ( t = <PLUS> | t = <MINUS>) expression()
		{
			jjtThis.setOp(t.image);
		}
	}
	
	void num() #Num:
	{
		Token t;
	}
	{
		 t = <NUM>
		 {
		 	jjtThis.setValue(Integer.parseInt(t.image));
		 }	
	}

